// This file is generated by tools/x86_64.d
module jupiter.x86_64.ir;

import std.sumtype, std.traits, jupiter.x86_64.info;

struct Imm(T){ T value; }
alias Imm8 = Imm!byte; alias Imm16 = Imm!short; alias Imm32 = Imm!int; alias Imm64 = Imm!long;

struct Reg(SizeType size) { Register value; this(Register reg) { this.value = reg; assert(reg.size == size, "Wrong sized register."); } }
alias Reg8 = Reg!(SizeType.s8); alias Reg16 = Reg!(SizeType.s16); alias Reg32 = Reg!(SizeType.s32); alias Reg64 = Reg!(SizeType.s64);

struct Mem
{
    enum Mode
    {
        disp,
        base_,
        baseIndex,
        baseDisp,
        baseIndexDisp,
        baseIndexScale,
        indexScaleDisp,
        baseIndexScaleDisp
    }

    Mode mode;
    IrExpression* disp;
    Register base_;
    Register index;
    int scale;

    invariant(scale == 0 || scale == 2 || scale == 4 || scale == 8);
}

struct IrLabel
{
    string fqn;
}

struct IrExpression
{
    alias Value = SumType!(
        long,
        string,
        IrLabel,
    );

    enum Op
    {
        constant,
        add,
        mul,
        div,
        sub
    }

    Op op;
    union
    {
        struct 
        {
            IrExpression* left;
            IrExpression* right;
        }

        Value constant;
    }
    long solvedValue;
}

alias Rm(SizeType size) = SumType!(Mem, Reg!size);
alias Rm8 = Rm!(SizeType.s8); alias Rm16 = Rm!(SizeType.s16); alias Rm32 = Rm!(SizeType.s32); alias Rm64 = Rm!(SizeType.s64); 

alias ImmExpression(T) = SumType!(IrExpression*, Imm!T);
alias Imm8Expression = ImmExpression!byte; alias Imm16Expression = ImmExpression!short; alias Imm32Expression = ImmExpression!int; alias Imm64Expression = ImmExpression!long; 
long solvedValue(T)(T exp)
if(isInstanceOf!(SumType, T))
{
    return exp.match!(
        (IrExpression* e) { return e.solvedValue; },
        (v) { return v.value; }
    );
}

alias IrValue = SumType!(
    Imm8,
    Imm16,
    Imm32,
    Imm64,
    Reg8,
    Reg16,
    Reg32,
    Reg64,
    Rm8,
    Rm16,
    Rm32,
    Rm64,
    Mem
);

// I need to use the GC for a linked list anyway, so may as well embrace the GC in full
abstract class Ir
{
    Ir next;
    Ir prev;
    abstract ubyte[] getBytes(scope ref return ubyte[32] bytes);
    abstract Instruction getInstruction();
}

private ubyte[] emit(alias Ir)(Ir ir, ref scope return ubyte[32] bytes)
{
    import std.bitmanip, std.algorithm, std.range;

    static struct Value { bool write; long value; int bytes; }

    size_t cursor;
    Value modrm, sib, imm, disp;
    Instruction.Rex rex = Ir.INSTRUCTION.rex;
    long opAdd;

    static if(Ir.INSTRUCTION.reg_t != Instruction.RegType.none)
    {
        modrm.write = true;
        modrm.value |= cast(ubyte)Ir.INSTRUCTION.reg_t << 3;
    }

    static foreach(i, oe; Ir.INSTRUCTION.op_e)
    {{
        const arg = argName(i);
        static if(oe == Instruction.OperandEncoding.add)
            opAdd = mixin("ir."~arg~".solvedValue");
        else static if(oe == Instruction.OperandEncoding.imm)
        {
            imm.write = true;
            imm.bytes = cast(int)Ir.INSTRUCTION.op_s[i];
            imm.value = mixin("ir."~arg~".solvedValue");
        }
        else static if(oe == Instruction.OperandEncoding.rm_reg)
        {
            modrm.write = true;
            modrm.value |= mixin("ir."~arg~".value.regNum") << 3;
            if(mixin("ir."~arg~".value.cat") >= Register.Category.r8) rex |= Instruction.Rex.r;
        }
        else static if(oe == Instruction.OperandEncoding.rm_rm)
        {
            modrm.write = true;
            Rm64 rm;
            static if(isInstanceOf!(Reg, mixin("Ir."~arg)))
                rm = typeof(rm)(mixin("ir."~arg));
            else static if(is(mixin("Ir."~arg) == Mem))
                rm = typeof(rm)(mixin("ir."~arg));
            else
                rm = mixin("ir."~arg);

            rm.match!(
                (Mem mem){
                    sib.write = true;
                    final switch(mem.mode)
                    {
                        case Mem.Mode.disp:
                            modrm.value |= 0b100;
                            sib.value = 0b00_100_101;
                            disp.write = true;
                            disp.bytes = 4;
                            disp.value = mem.disp.solvedValue;
                            break;
                        case Mem.Mode.base_:
                            modrm.value |= 0b100;
                            sib.value = 0b00_100_000;
                            sib.value |= mem.base_.regNum;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            break;
                        case Mem.Mode.baseIndex:
                            modrm.value |= 0b100;
                            sib.value |= mem.index.regNum << 3;
                            sib.value |= mem.base_.regNum;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                        case Mem.Mode.baseDisp:
                            disp.write = true;
                            disp.value = mem.disp.solvedValue;
                            if(disp.value <= byte.max)
                            {
                                modrm.value |= 0b01_000_000;
                                disp.bytes = 1;
                            }
                            else
                            {
                                modrm.value |= 0b10_000_000;
                                disp.bytes = 4;
                            }
                            sib.write = false;
                            modrm.value |= mem.base_.regNum;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            break;
                        case Mem.Mode.baseIndexDisp:
                            disp.write = true;
                            disp.value = mem.disp.solvedValue;
                            if(disp.value <= byte.max)
                            {
                                modrm.value |= 0b01_000_100;
                                disp.bytes = 1;
                            }
                            else
                            {
                                modrm.value |= 0b10_000_100;
                                disp.bytes = 4;
                            }
                            sib.value |= mem.base_.regNum;
                            sib.value |= mem.index.regNum << 3;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                        case Mem.Mode.baseIndexScale:
                            modrm.value |= 0b100;
                            sib.value |= mem.base_.regNum;
                            sib.value |= mem.index.regNum << 3;
                            sib.value |= (mem.scale == 2 ? 0b01 : mem.scale == 4 ? 0b10 : 0b11) << 6;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                        case Mem.Mode.indexScaleDisp:
                            disp.write = true;
                            disp.bytes = 4;
                            disp.value = mem.disp.solvedValue;
                            modrm.value |= 0b100;
                            sib.value |= 0b101;
                            sib.value |= mem.index.regNum << 3;
                            sib.value |= (mem.scale == 2 ? 0b01 : mem.scale == 4 ? 0b10 : 0b11) << 6;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                        case Mem.Mode.baseIndexScaleDisp:
                            disp.write = true;
                            disp.value = mem.disp.solvedValue;
                            if(disp.value <= byte.max)
                            {
                                modrm.value |= 0b01_000_100;
                                disp.bytes = 1;
                            }
                            else
                            {
                                modrm.value |= 0b10_000_100;
                                disp.bytes = 4;
                            }
                            sib.value |= mem.base_.regNum;
                            sib.value |= mem.index.regNum << 3;
                            sib.value |= (mem.scale == 2 ? 0b01 : mem.scale == 4 ? 0b10 : 0b11) << 6;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                    }
                },
                (reg){
                    modrm.write = true;
                    modrm.value |= reg.value.regNum;
                    if(reg.value.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                }
            );
        }
    }}

    static if(Ir.INSTRUCTION.p_g2 != G2Prefix.none)
        bytes[cursor++] = cast(ubyte)Ir.INSTRUCTION.p_g2;
    static if(Ir.INSTRUCTION.p_g3 != G3Prefix.none)
        bytes[cursor++] = cast(ubyte)Ir.INSTRUCTION.p_g3;
    static if(Ir.INSTRUCTION.p_g4 != G4Prefix.none)
        bytes[cursor++] = cast(ubyte)Ir.INSTRUCTION.p_g4;

    if(rex != Instruction.Rex.none)
        bytes[cursor++] = cast(ubyte)(rex | 0x40);

    static foreach(op; Ir.INSTRUCTION.op)
        bytes[cursor++] = cast(ubyte)(op + opAdd);

    if(modrm.write)
    {
        assert(modrm.value <= ubyte.max);
        bytes[cursor++] = cast(ubyte)modrm.value;
    }
    if(sib.write)
    {
        assert(sib.value <= ubyte.max);
        bytes[cursor++] = cast(ubyte)sib.value;
    }
    if(disp.write)
    {
        bytes[cursor..cursor+disp.bytes] = nativeToLittleEndian(disp.value)[0..disp.bytes];
        cursor += disp.bytes;
    }
    if(imm.write)
    {
        bytes[cursor..cursor+imm.bytes] = nativeToLittleEndian(imm.value)[0..imm.bytes];
        cursor += imm.bytes;
    }

    return bytes[0..cursor];
}

private string argName(int i)
{
    import std.conv;
    return "arg"~i.to!string;
}