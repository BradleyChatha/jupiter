// Mneumonics as the lexer sees them. Parser gets its own set of info for them.
module jupiter.assembler.info;

import std;

MneumonicHigh[string] g_highMneumonics;
Register[string] g_registers;
SizeType[string] g_sizeTypes;

shared static this()
{
    static foreach(member; __traits(allMembers, MneumonicHigh))
        g_highMneumonics[member] = mixin("MneumonicHigh."~member);
    static foreach(reg; Registers)
        g_registers[reg.name] = reg;
    g_sizeTypes = [
        "byte": SizeType.imm8,
        "word": SizeType.imm16,
        "dword": SizeType.imm32,
        "qword": SizeType.imm64,
    ];
}

enum SizeType
{
    infer,
    imm8,
    imm16,
    imm32,
    imm64
}

struct Register
{
    enum Category
    {
        rax,
        rcx,
        rdx,
        rbx,
        rsp,
        rbp,
        rsi,
        rdi,
        r8,
        r9,
        r10,
        r11,
        r12,
        r13,
        r14,
        r15
    }

    string name;
    Instruction.OperandType type; // Only the "r" values are valid.
    Category cat;
    ubyte regNum;
}

enum Prefix
{
    none,
    lock,
    rep,
    repnz
}

enum G2Prefix
{
    none,
    cs = 0x2E,
    ss = 0x36,
    ds = 0x3E,
    es = 0x26,
    fs = 0x64,
    gs = 0x65,
}

enum G3Prefix
{
    none,
    opSize = 0x66
}

enum G4Prefix
{
    none,
    addrSize = 0x67
}

private alias pg1 = Prefix;
private alias pg2 = G2Prefix;
private alias pg3 = G3Prefix;
private alias pg4 = G4Prefix;

private alias rc = Register.Category;
private alias rt = Instruction.OperandType;
private alias r = Register;
immutable Registers = [
    r("rax",    rt.r64, rc.rax, 0), r("eax",    rt.r32, rc.rax, 0), r("ax",     rt.r16, rc.rax, 0), r("ah",     rt.r8, rc.rax, 0), r("al", rt.r8, rc.rax, 0),
    r("rbx",    rt.r64, rc.rbx, 3), r("ebx",    rt.r32, rc.rbx, 3), r("bx",     rt.r16, rc.rbx, 3), r("bh",     rt.r8, rc.rbx, 3), r("bl", rt.r8, rc.rbx, 3),
    r("rcx",    rt.r64, rc.rcx, 1), r("ecx",    rt.r32, rc.rcx, 1), r("cx",     rt.r16, rc.rcx, 1), r("ch",     rt.r8, rc.rcx, 1), r("cl", rt.r8, rc.rcx, 1),
    r("rdx",    rt.r64, rc.rdx, 2), r("edx",    rt.r32, rc.rdx, 2), r("dx",     rt.r16, rc.rdx, 2), r("dh",     rt.r8, rc.rdx, 2), r("dl", rt.r8, rc.rdx, 2),
    r("rsi",    rt.r64, rc.rsi, 6), r("esi",    rt.r32, rc.rsi, 6), r("si",     rt.r16, rc.rsi, 6), r("sil",    rt.r8, rc.rsi, 6),
    r("rdi",    rt.r64, rc.rdi, 7), r("edi",    rt.r32, rc.rdi, 7), r("di",     rt.r16, rc.rdi, 7), r("dil",    rt.r8, rc.rdi, 7),
    r("rsp",    rt.r64, rc.rsp, 4), r("esp",    rt.r32, rc.rsp, 4), r("sp",     rt.r16, rc.rsp, 4), r("spl",    rt.r8, rc.rsp, 4),
    r("rbp",    rt.r64, rc.rbp, 5), r("ebp",    rt.r32, rc.rbp, 5), r("bp",     rt.r16, rc.rbp, 5), r("bpl",    rt.r8, rc.rbp, 5),
    r("r8",     rt.r64, rc.r8,  0), r("r8d",    rt.r32, rc.r8,  0), r("r8w",    rt.r16, rc.r8,  0), r("r8b",    rt.r8, rc.r8,  0),
    r("r9",     rt.r64, rc.r9,  1), r("r9d",    rt.r32, rc.r9,  1), r("r9w",    rt.r16, rc.r9,  1), r("r9b",    rt.r8, rc.r9,  1),
    r("r10",    rt.r64, rc.r10, 2), r("r10d",   rt.r32, rc.r10, 2), r("r10w",   rt.r16, rc.r10, 2), r("r10b",   rt.r8, rc.r10, 2),
    r("r11",    rt.r64, rc.r11, 3), r("r11d",   rt.r32, rc.r11, 3), r("r11w",   rt.r16, rc.r11, 3), r("r11b",   rt.r8, rc.r11, 3),
    r("r12",    rt.r64, rc.r12, 4), r("r12d",   rt.r32, rc.r12, 4), r("r12w",   rt.r16, rc.r12, 4), r("r12b",   rt.r8, rc.r12, 4),
    r("r13",    rt.r64, rc.r13, 5), r("r13d",   rt.r32, rc.r13, 5), r("r13w",   rt.r16, rc.r13, 5), r("r13b",   rt.r8, rc.r13, 5),
    r("r14",    rt.r64, rc.r14, 6), r("r14d",   rt.r32, rc.r14, 6), r("r14w",   rt.r16, rc.r14, 6), r("r14b",   rt.r8, rc.r14, 6),
    r("r15",    rt.r64, rc.r15, 7), r("r15d",   rt.r32, rc.r15, 7), r("r15w",   rt.r16, rc.r15, 7), r("r15b",   rt.r8, rc.r15, 7),
];

struct Instruction
{
    enum OperandType
    {
        none,
        _infer  = -1,
        _label  = -2,
        _m      = -3,
        r8      = 1 << 0,
        r16     = 1 << 1,
        r32     = 1 << 2,
        r64     = 1 << 3,
        imm8    = 1 << 4,
        imm16   = 1 << 5,
        imm32   = 1 << 6,
        imm64   = 1 << 7,
        m8      = 1 << 8,
        m16     = 1 << 9,
        m32     = 1 << 10,
        m64     = 1 << 11,

        rm8     = 1 << 12,
        rm16    = 1 << 13,
        rm32    = 1 << 14,
        rm64    = 1 << 15,
    }

    enum OperandEncoding
    {
        none,
        rm_rm,
        rm_reg,
        imm,
        add
    }

    enum Rex : ubyte
    {
        none,
        w = 1 << 3,
        r = 1 << 2,
        x = 1 << 1,
        b = 1 << 0,
    }

    enum RegType
    {
        none  = -1,
        r     = -2,
        reg0 = 0,
        reg1 = 1,
        reg2 = 2,
        reg3 = 3,
        reg4 = 4,
        reg5 = 5,
        reg6 = 6,
        reg7 = 7,
    }

    MneumonicHigh mneumonic;
    string debugName;
    G2Prefix p_g2;
    G3Prefix p_g3;
    G4Prefix p_g4;
    Rex rex;
    RegType reg_t;
    ubyte op_c;
    ubyte op_1;
    ubyte op_2;
    ubyte op_3;
    OperandType o1_t;
    OperandType o2_t;
    OperandType o3_t;
    OperandEncoding o1_e;
    OperandEncoding o2_e;
    OperandEncoding o3_e;
}

alias i = Instruction;
alias iot = Instruction.OperandType;
alias ioe = Instruction.OperandEncoding;
alias ireg = Instruction.RegType;
alias rex = Instruction.Rex;
alias mh = MneumonicHigh;

// High as in High-level
// Parser will deconstruct them down into more specific mneumonics.
enum MneumonicHigh
{
    FAILSAFE,

    // PSUEDO_MNEUMONICS
    db, dw, dd, dq,

    // ACTUAL_MNEUMONICS
    aaa,
    aad,
    aam,
    aas,
    adc,
    adcx,
    add,
    addpd,
    addps,
    addsd,
    addss,
    addsubpd,
    addsubps,
    adox,
    aesdec,
    aesdeclast,
    aesenc,
    aesenclast,
    aesimc,
    aeskeygenassist,
    and,
    andn,
    andnpd,
    andnps,
    andpd,
    andps,
    arpl,
    bexter,
    blendpd,
    blendps,
    blendvpd,
    blendvps,
    blsi,
    blsmsk,
    blsr,
    bndcl,
    bndcn,
    bndcu,
    bndldx,
    bndmk,
    bndmov,
    bndstx,
    bound,
    bsf,
    bsr,
    bswap,
    bt,
    btc,
    btr,
    bts,
    bzhi,
    call,
    cbw,
    cdq,
    cdqe,
    clac,
    clc,
    cld,
    cldemote,
    clflush,
    clflushopt,
    cli,
    clts,
    clwb,
    cmc,
    cmova,
    cmovae,
    cmovb,
    cmovbe,
    cmovc,
    cmove,
    cmovg,
    cmovge,
    cmovl,
    cmovle,
    cmovna,
    cmovnae,
    cmovnb,
    cmovnbe,
    cmovnc,
    cmovne,
    comvng,
    cmovnge,
    cmovnl,
    cmovnle,
    cmovno,
    cmovnp,
    cmovns,
    cmovnz,
    cmovo,
    cmovp,
    cmovpe,
    cmovpo,
    cmovs,
    cmovz,
    cmp,
    cmppd,
    cmpps,
    cmps,
    cmpsb,
    cmpsd,
    cmpsq,
    cmpsw,
    cmpss,
    cmpxchg,
    cmpxchg16b,
    cmpxchg8b,
    cmoisd,
    comiss,
    cpuid,
    cqo,
    crc32,
    cvtdq2pd,
    cvtdq2ps,
    cvtpd2dq,
    cvtpd2pi,
    cvtpd2ps,
    cvtpi2pd,
    cvtpi2ps,
    cvtps2dq,
    cvtps2pd,
    cvtps2pi,
    cvtsd2si,
    cvtsd2ss,
    cvtsi2sd,
    cvtsi2ss,
    cvtss2sd,
    cvtss2si,
    cvttpd2dq,
    cvttpd2pi,
    cvttps2dq,
    cvttsd2si,
    cvttss2si,
    cwd,
    cwde,
    daa,
    das,
    dec,
    div,
    divpd,
    divps,
    divsd,
    divss,
    dppd,
    dpps,
    emms,
    enter,
    extractps,
    f2xm1,
    fabs,
    fadd,
    faddp,
    fbld,
    fbstp,
    fchs,
    fclex,
    fcmova,
    fcmovae,
    fcmovb,
    fcmovbe,
    fcmovc,
    fcmove,
    fcmovg,
    fcmovge,
    fcmovl,
    fcmovle,
    fcmovna,
    fcmovnae,
    fcmovnb,
    fcmovnbe,
    fcmovnc,
    fcmovne,
    fcomvng,
    fcmovnge,
    fcmovnl,
    fcmovnle,
    fcmovno,
    fcmovnp,
    fcmovns,
    fcmovnz,
    fcmovo,
    fcmovp,
    fcmovpe,
    fcmovpo,
    fcmovs,
    fcmovz,
    fcom,
    fcomip,
    fcomp,
    fcompp,
    fcos,
    fcdecstp,
    fdiv,
    fdivp,
    fdivr,
    fdivrp,
    ffree,
    fiadd,
    ficom,
    ficomp,
    fidiv,
    fidivr,
    fild,
    fimul,
    fincstp,
    finit,
    fist,
    fistp,
    fisttp,
    fisub,
    fisubr,
    fld,
    fld1,
    fldcw,
    fldenv,
    fldle2e,
    fldl2t,
    fldlg2,
    fldln2,
    fldpi,
    fldz,
    fmul,
    fmulp,
    fnclex,
    fninit,
    fnop,
    fnsave,
    fnstcw,
    fnstenv,
    fnstsw,
    fpatan,
    fprem,
    fprem1,
    fptan,
    frndint,
    frstor,
    fsave,
    fscale,
    fsin,
    fsincos,
    fsqrt,
    fst,
    fstcw,
    fstenv,
    fstp,
    fstsw,
    fsub,
    fsubp,
    fsubr,
    fsubrp,
    ftst,
    fucom,
    fucomi,
    fucomip,
    fucmp,
    fucompp,
    fwait,
    fxam,
    fxch,
    fxrstor,
    fxsave,
    fxtract,
    fyl2x,
    fyl2xp1,
    gf2p8affineinvqb,
    gf2p8affineqb,
    gf2p8mulb,
    haddpd,
    haddps,
    hlt,
    hsubpd,
    hsubps,
    idiv,
    imul,
    in_,
    inc,
    ins,
    insb,
    insd,
    insertps,
    insw,
    int_,
    int1,
    int3,
    into,
    invd,
    invlpg,
    invpcid,
    iret,
    iretd,
    jmp,
    ja,
    jae,
    jb,
    jbe,
    jc,
    je,
    jg,
    jge,
    jl,
    jle,
    jna,
    jnae,
    jnb,
    jnbe,
    jnc,
    jne,
    jng,
    jnge,
    jnl,
    jnle,
    jno,
    jnp,
    jns,
    jnz,
    jo,
    jp,
    jpe,
    jpo,
    js,
    jz,
    kaddb,
    kaddd,
    kaddq,
    kaddw,
    kandb,
    kandnb,
    kandnq,
    kandnw,
    kandq,
    kandw,
    kmovb,
    kmovd,
    kmovq,
    kmovw,
    knotb,
    knotd,
    knotq,
    knotw,
    korb,
    kord,
    korq,
    kortestb,
    kortestd,
    kortestq,
    kortestw,
    korw,
    kshiftlb,
    kshiftld,
    kshiftlq,
    kshiftlw,
    kshiftrb,
    kshiftrd,
    kshiftrq,
    kshiftrw,
    ktestb,
    ktestd,
    ktestq,
    ktestw,
    kunpckbw,
    kunpckdq,
    kunpckwd,
    kxnorb,
    kxnord,
    kxnorq,
    kxnorw,
    kxorb,
    kxord,
    kxorq,
    kxorw,
    lahf,
    lar,
    lddqu,
    ldmxcsr,
    lds,
    lea,
    leave,
    les,
    lfence,
    lfs,
    lgdt,
    lgs,
    lidt,
    lldt,
    lmsw,
    lock,
    lods,
    lodsb,
    lodsd,
    lodsq,
    lodsw,
    loop,
    loope,
    loopne,
    lsl,
    lss,
    ltr,
    lzcnt,
    maskmovdqu,
    maskmovq,
    maxpd,
    mpaxps,
    maxsd,
    maxss,
    mfence,
    minpd,
    minps,
    minsd,
    minss,
    monitor,
    mov,
    movapd,
    movaps,
    movbe,
    movd,
    movddup,
    movdir64,
    mivdiri,
    movdq2q,
    movdqa,
    movdqu,
    movhlps,
    movhpd,
    movhps,
    movlhps,
    movlpd,
    movlps,
    movmskpd,
    movmskps,
    movntdq,
    movntdqqa,
    movnti,
    movntpd,
    movntps,
    monntq,
    movq,
    movq2dq,
    movs,
    movsb,
    movsd,
    movshdup,
    movsldup,
    movsq,
    movss,
    movsw,
    movsx,
    movsxd,
    movupd,
    movups,
    movzx,
    mpsadbw,
    mul,
    mulpd,
    mulps,
    mulsd,
    mulss,
    mulx,
    mwait,
    neg,
    nop,
    not,
    or,
    orpd,
    orps,
    out_,
    outs,
    outsb,
    outsd,
    outsw,
    pabsb,
    pabsd,
    pabsq,
    pabsw,
    packssdw,
    packsswb,
    packusdw,
    packuswb,
    paddb,
    paddd,
    paddq,
    paddsb,
    paddsw,
    paddusb,
    paddusw,
    paddw,
    palignr,
    pand,
    pandn,
    pause,
    pavgb,
    pavgw,
    pblendvb,
    pblendw,
    pclmulqdq,
    pcmpeqb,
    pcmpeqd,
    pcmpeqq,
    pcmpeqw,
    pcmpestri,
    pcmpstrm,
    pcmpgtb,
    pcmpgtd,
    pcmpgtq,
    pcmpgtw,
    mpcmpistri,
    pcmpistrm,
    pdep,
    mpext,
    pextrb,
    pextrd,
    pextrq,
    pextrw,
    phaddd,
    phaddsw,
    phaddw,
    phimposuw,
    phsubd,
    phsubsw,
    phsubw,
    pinsrb,
    pinsrd,
    pinsrq,
    pinsrw,
    pmaddubsw,
    pmaddwd,
    pmaxsb,
    pmaxsd,
    pmaxsq,
    pmaxsw,
    pmaxub,
    pmaxud,
    pmaxuq,
    pmaxuw,
    
    ptest,
    ptwrite,
    punpckhbw,
    punpckhdq,
    punpckhqdq,
    puncpkhwd,
    punpcklbw,
    punpckldq,
    punpcklqdq,
    punpcklwd,
    push,
    pusha,
    pushad,
    pushf,
    pushfd,
    pushfq,
    pxor,
    rcl,
    rcpps,
    rcpss,
    rcr,
    rdfsbase,
    rdgsbase,
    rdmsr,
    rdpid,
    rdpkru,
    rdpmc,
    rdrand,
    rdseed,
    rdtsc,
    rdtscp,
    rep,
    repe,
    repne,
    repnz,
    repz,
    ret,
    rol,
    ror,
    rorx,
    roundpd,
    roundps,
    roundsd,
    roundss,
    rsm,
    rsqrtps,
    rsqrtss,
    sahf,
    sal,
    sar,
    sarx,
    sbb,
    scas,
    scasb,
    scasd,
    scasw,
    sfence,
    sgdt,
    sha1msg1,
    sha1msg2,
    sha1nexte,
    sha1rnds4,
    sha256ms1,
    sha256msg2,
    sha256rnds2,
    shl,
    shld,
    shlx,
    shr,
    shrd,
    shrx,
    shufpd,
    shufps,
    sidt,
    sldt,
    smsw,
    sqrtpd,
    sqrtps,
    sqrtsd,
    sqrtss,
    stac,
    stc,
    std,
    sti,
    stmxcsr,
    stos,
    stosb,
    stosd,
    stosq,
    stosw,
    str,
    sub,
    subpd,
    subps,
    subsd,
    subss,
    swapgs,
    syscall,
    sysenter,
    sysexit,
    sysret,
    test,
    tpause,
    tzcnt,
    ucomisd,
    ucomiss,
    ud,
    umonitor,
    unwait,
    unpckhpd,
    unpckhps,
    unpcklpd,
    unpcklps,
    valignd,
    valignq,
    
    wait,
    wbinvd,
    wrfsbase,
    wrgsbase,
    wrmsr,
    wrpkru,
    xabort,
    xacquire,
    xadd,
    xbegin,
    xchg,
    xend,
    xgetbv,
    xlat,
    xlatb,
    xor,
    xorpd,
    xorps,
    xrelease,
    xrstor,
    xrstors,
    xsave,
    xsavec,
    xsaveopt,
    xsaves,
    xsetbv,
    xtest
}

immutable INSTRUCTIONS = [
    // KEEP INSTRUCTIONS WITH THE SAME mh ADJACENT TO EACH OTHER
    i(mh.add, "add_rm8_i8",         pg2.none,       pg3.none,       pg4.none,   rex.none,   ireg.reg0,  1, 0x00, 0x00, 0x80,   iot.rm8,    iot.imm8,     iot.none,   ioe.rm_rm,  ioe.imm,    ioe.none),
    i(mh.add, "add_rm16_i16",       pg2.none,       pg3.none,       pg4.none,   rex.none,   ireg.reg0,  1, 0x00, 0x00, 0x81,   iot.rm16,   iot.imm16,    iot.none,   ioe.rm_rm,  ioe.imm,    ioe.none),
    i(mh.add, "add_rm32_i32",       pg2.none,       pg3.none,       pg4.none,   rex.none,   ireg.reg0,  1, 0x00, 0x00, 0x81,   iot.rm32,   iot.imm32,    iot.none,   ioe.rm_rm,  ioe.imm,    ioe.none),
    i(mh.add, "add_rm64_i32",       pg2.none,       pg3.none,       pg4.none,   rex.w,      ireg.reg0,  1, 0x00, 0x00, 0x81,   iot.rm64,   iot.imm32,    iot.none,   ioe.rm_rm,  ioe.imm,    ioe.none),
    i(mh.add, "add_rm8_r8",         pg2.none,       pg3.none,       pg4.none,   rex.none,   ireg.r,     1, 0x00, 0x00, 0x00,   iot.rm8,    iot.r8,       iot.none,   ioe.rm_rm,  ioe.rm_reg, ioe.none),
    i(mh.add, "add_rm16_r16",       pg2.none,       pg3.opSize,     pg4.none,   rex.none,   ireg.r,     1, 0x00, 0x00, 0x01,   iot.rm16,   iot.r16,      iot.none,   ioe.rm_rm,  ioe.rm_reg, ioe.none),
    i(mh.add, "add_rm32_r32",       pg2.none,       pg3.none,       pg4.none,   rex.none,   ireg.r,     1, 0x00, 0x00, 0x01,   iot.rm32,   iot.r32,      iot.none,   ioe.rm_rm,  ioe.rm_reg, ioe.none),
    i(mh.add, "add_rm64_r64",       pg2.none,       pg3.none,       pg4.none,   rex.w,      ireg.r,     1, 0x00, 0x00, 0x01,   iot.rm64,   iot.r64,      iot.none,   ioe.rm_rm,  ioe.rm_reg, ioe.none),
    i(mh.lea, "lea_r64_m64",        pg2.none,       pg3.none,       pg4.none,   rex.w,      ireg.r,     1, 0x00, 0x00, 0x8D,   iot.r64,    iot.m64,      iot.none,   ioe.rm_reg, ioe.rm_rm,  ioe.none),
    i(mh.ret, "retn",               pg2.none,       pg3.none,       pg4.none,   rex.none,   ireg.none,  1, 0x00, 0x00, 0xC3,   iot.none,   iot.none,     iot.none,   ioe.none,   ioe.none,   ioe.none),
];  