// This file is generated by tools/x86_64.d
module jupiter.x86_64.ir;

import std.sumtype, std.traits, jupiter.x86_64.info;

struct Imm(T){ T value; }
alias Imm8 = Imm!byte; alias Imm16 = Imm!short; alias Imm32 = Imm!int; alias Imm64 = Imm!long;

struct Reg(SizeType size) { Register value; this(Register reg) { this.value = reg; assert(reg.size == size, "Wrong sized register."); } }
alias Reg8 = Reg!(SizeType.s8); alias Reg16 = Reg!(SizeType.s16); alias Reg32 = Reg!(SizeType.s32); alias Reg64 = Reg!(SizeType.s64);

struct Mem
{
    enum Mode
    {
        disp,
        base_,
        baseIndex,
        baseDisp,
        baseIndexDisp,
        baseIndexScale,
        indexScaleDisp,
        baseIndexScaleDisp
    }

    Mode mode;
    long disp;
    Register base_;
    Register index;
    int scale;

    invariant(scale == 0 || scale == 2 || scale == 4 || scale == 8);
}

alias Rm(SizeType size) = SumType!(Mem, Reg!size);
alias Rm8 = Rm!(SizeType.s8); alias Rm16 = Rm!(SizeType.s16); alias Rm32 = Rm!(SizeType.s32); alias Rm64 = Rm!(SizeType.s64); 

alias IrValue = SumType!(
    Imm8,
    Imm16,
    Imm32,
    Imm64,
    Reg8,
    Reg16,
    Reg32,
    Reg64,
    Rm8,
    Rm16,
    Rm32,
    Rm64,
    Mem
);

// I need to use the GC for a linked list anyway, so may as well embrace the GC in full
abstract class Ir
{
    Ir next;
    Ir prev;
    abstract ubyte[] getBytes(scope ref return ubyte[32] bytes);
    abstract Instruction getInstruction();
}

private ubyte[] emit(alias Ir)(Ir ir, ref scope return ubyte[32] bytes)
{
    import std.bitmanip, std.algorithm, std.range;

    static struct Value { bool write; long value; int bytes; }

    size_t cursor;
    Value modrm, sib, imm, disp;
    Instruction.Rex rex = Ir.INSTRUCTION.rex;
    long opAdd;

    static if(Ir.INSTRUCTION.reg_t != Instruction.RegType.none)
    {
        modrm.write = true;
        modrm.value |= cast(ubyte)Ir.INSTRUCTION.reg_t << 3;
    }

    static foreach(i, oe; Ir.INSTRUCTION.op_e)
    {{
        const arg = argName(i);
        static if(oe == Instruction.OperandEncoding.add)
            opAdd = mixin("ir."~arg~".value");
        else static if(oe == Instruction.OperandEncoding.imm)
        {
            imm.write = true;
            imm.bytes = cast(int)Ir.INSTRUCTION.op_s[i];
            imm.value = mixin("ir."~arg~".value");
        }
        else static if(oe == Instruction.OperandEncoding.rm_reg)
        {
            modrm.write = true;
            modrm.value |= mixin("ir."~arg~".value.regNum") << 3;
            if(mixin("ir."~arg~".value.cat") >= Register.Category.r8) rex |= Instruction.Rex.r;
        }
        else static if(oe == Instruction.OperandEncoding.rm_rm)
        {
            modrm.write = true;
            Rm64 rm;
            static if(isInstanceOf!(Reg, mixin("Ir."~arg)))
                rm = typeof(rm)(mixin("ir."~arg));
            else static if(is(mixin("Ir."~arg) == Mem))
                rm = typeof(rm)(mixin("ir."~arg));
            else
                rm = mixin("ir."~arg);

            rm.match!(
                (Mem mem){
                    sib.write = true;
                    final switch(mem.mode)
                    {
                        case Mem.Mode.disp:
                            modrm.value |= 0b100;
                            sib.value = 0b00_100_101;
                            disp.write = true;
                            disp.bytes = 4;
                            disp.value = mem.disp;
                            break;
                        case Mem.Mode.base_:
                            modrm.value |= 0b100;
                            sib.value = 0b00_100_000;
                            sib.value |= mem.base_.regNum;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            break;
                        case Mem.Mode.baseIndex:
                            modrm.value |= 0b100;
                            sib.value |= mem.index.regNum << 3;
                            sib.value |= mem.base_.regNum;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                        case Mem.Mode.baseDisp:
                            disp.write = true;
                            disp.value = mem.disp;
                            if(disp.value <= byte.max)
                            {
                                modrm.value |= 0b01_000_000;
                                disp.bytes = 1;
                            }
                            else
                            {
                                modrm.value |= 0b10_000_000;
                                disp.bytes = 4;
                            }
                            sib.write = false;
                            modrm.value |= mem.base_.regNum;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            break;
                        case Mem.Mode.baseIndexDisp:
                            disp.write = true;
                            disp.value = mem.disp;
                            if(disp.value <= byte.max)
                            {
                                modrm.value |= 0b01_000_100;
                                disp.bytes = 1;
                            }
                            else
                            {
                                modrm.value |= 0b10_000_100;
                                disp.bytes = 4;
                            }
                            sib.value |= mem.base_.regNum;
                            sib.value |= mem.index.regNum << 3;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                        case Mem.Mode.baseIndexScale:
                            modrm.value |= 0b100;
                            sib.value |= mem.base_.regNum;
                            sib.value |= mem.index.regNum << 3;
                            sib.value |= (mem.scale == 2 ? 0b01 : mem.scale == 4 ? 0b10 : 0b11) << 6;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                        case Mem.Mode.indexScaleDisp:
                            disp.write = true;
                            disp.bytes = 4;
                            disp.value = mem.disp;
                            modrm.value |= 0b100;
                            sib.value |= 0b101;
                            sib.value |= mem.index.regNum << 3;
                            sib.value |= (mem.scale == 2 ? 0b01 : mem.scale == 4 ? 0b10 : 0b11) << 6;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                        case Mem.Mode.baseIndexScaleDisp:
                            disp.write = true;
                            disp.value = mem.disp;
                            if(disp.value <= byte.max)
                            {
                                modrm.value |= 0b01_000_100;
                                disp.bytes = 1;
                            }
                            else
                            {
                                modrm.value |= 0b10_000_100;
                                disp.bytes = 4;
                            }
                            sib.value |= mem.base_.regNum;
                            sib.value |= mem.index.regNum << 3;
                            sib.value |= (mem.scale == 2 ? 0b01 : mem.scale == 4 ? 0b10 : 0b11) << 6;
                            if(mem.base_.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                            if(mem.index.cat >= Register.Category.r8) rex |= Instruction.Rex.x;
                            break;
                    }
                },
                (reg){
                    modrm.write = true;
                    modrm.value |= reg.value.regNum;
                    if(reg.value.cat >= Register.Category.r8) rex |= Instruction.Rex.b;
                }
            );
        }
    }}

    static if(Ir.INSTRUCTION.p_g2 != G2Prefix.none)
        bytes[cursor++] = cast(ubyte)Ir.INSTRUCTION.p_g2;
    static if(Ir.INSTRUCTION.p_g3 != G3Prefix.none)
        bytes[cursor++] = cast(ubyte)Ir.INSTRUCTION.p_g3;
    static if(Ir.INSTRUCTION.p_g4 != G4Prefix.none)
        bytes[cursor++] = cast(ubyte)Ir.INSTRUCTION.p_g4;

    if(rex != Instruction.Rex.none)
        bytes[cursor++] = cast(ubyte)(rex | 0x40);

    static foreach(op; Ir.INSTRUCTION.op)
        bytes[cursor++] = cast(ubyte)(op + opAdd);

    if(modrm.write)
    {
        assert(modrm.value <= ubyte.max);
        bytes[cursor++] = cast(ubyte)modrm.value;
    }
    if(sib.write)
    {
        assert(sib.value <= ubyte.max);
        bytes[cursor++] = cast(ubyte)sib.value;
    }
    if(disp.write)
    {
        bytes[cursor..cursor+disp.bytes] = nativeToLittleEndian(disp.value)[0..disp.bytes];
        cursor += disp.bytes;
    }
    if(imm.write)
    {
        bytes[cursor..cursor+imm.bytes] = nativeToLittleEndian(imm.value)[0..imm.bytes];
        cursor += imm.bytes;
    }

    return bytes[0..cursor];
}

private string argName(int i)
{
    import std.conv;
    return "arg"~i.to!string;
}final class addali8 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[0];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[0]; }
    Reg8 arg0;
    Imm8 arg1;
    this(Imm8 arg1)
    {
        this.arg0 = regi!"al";
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addaxi16 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[1];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[1]; }
    Reg16 arg0;
    Imm16 arg1;
    this(Imm16 arg1)
    {
        this.arg0 = regi!"ax";
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addeaxi32 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[2];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[2]; }
    Reg32 arg0;
    Imm32 arg1;
    this(Imm32 arg1)
    {
        this.arg0 = regi!"eax";
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addraxi32 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[3];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[3]; }
    Reg64 arg0;
    Imm32 arg1;
    this(Imm32 arg1)
    {
        this.arg0 = regi!"rax";
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm8i8 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[4];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[4]; }
    Rm64 arg0;
    Imm8 arg1;
    this(Rm64 arg0, Imm8 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addsxrm8i8 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[5];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[5]; }
    Rm64 arg0;
    Imm8 arg1;
    this(Rm64 arg0, Imm8 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm16i16 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[6];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[6]; }
    Rm64 arg0;
    Imm16 arg1;
    this(Rm64 arg0, Imm16 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm32i32 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[7];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[7]; }
    Rm64 arg0;
    Imm32 arg1;
    this(Rm64 arg0, Imm32 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm64i32 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[8];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[8]; }
    Rm64 arg0;
    Imm32 arg1;
    this(Rm64 arg0, Imm32 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm16i8 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[9];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[9]; }
    Rm64 arg0;
    Imm8 arg1;
    this(Rm64 arg0, Imm8 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm32i8 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[10];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[10]; }
    Rm64 arg0;
    Imm8 arg1;
    this(Rm64 arg0, Imm8 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm64i8 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[11];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[11]; }
    Rm64 arg0;
    Imm8 arg1;
    this(Rm64 arg0, Imm8 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm8r8 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[12];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[12]; }
    Rm64 arg0;
    Reg8 arg1;
    this(Rm64 arg0, Reg8 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm16r16 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[13];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[13]; }
    Rm64 arg0;
    Reg16 arg1;
    this(Rm64 arg0, Reg16 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm32r32 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[14];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[14]; }
    Rm64 arg0;
    Reg32 arg1;
    this(Rm64 arg0, Reg32 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addrm64r64 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[15];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[15]; }
    Rm64 arg0;
    Reg64 arg1;
    this(Rm64 arg0, Reg64 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addr8rm8 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[16];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[16]; }
    Reg8 arg0;
    Rm64 arg1;
    this(Reg8 arg0, Rm64 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addr16rm16 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[17];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[17]; }
    Reg16 arg0;
    Rm64 arg1;
    this(Reg16 arg0, Rm64 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addr32rm32 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[18];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[18]; }
    Reg32 arg0;
    Rm64 arg1;
    this(Reg32 arg0, Rm64 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
final class addr64rm64 : Ir {
    static immutable INSTRUCTION = INSTRUCTIONS[19];
    override Instruction getInstruction() { return cast()INSTRUCTIONS[19]; }
    Reg64 arg0;
    Rm64 arg1;
    this(Reg64 arg0, Rm64 arg1)
    {
        this.arg0 = arg0;
        this.arg1 = arg1;
    }

    override ubyte[] getBytes(scope ref return ubyte[32] bytes)
    {
        return emit!(typeof(this))(this, bytes);
    }
}
